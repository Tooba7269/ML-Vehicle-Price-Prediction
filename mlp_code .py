# -*- coding: utf-8 -*-
"""MLP.code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zJyXl1L1kwoYvLw_kRzlbQly0TLG-YQt

#**Import Libraries and Packages**
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
!pip install category_encoders
# %matplotlib inline
import numpy as np
import pandas as pd
import category_encoders as ce
import matplotlib.pyplot as plt
import seaborn as sns


sns.set(
    { "figure.figsize": (4, 4) },
    style='ticks',
    color_codes=True,
    font_scale=0.8
)
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import PredictionErrorDisplay
from sklearn.neighbors import KNeighborsRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import GridSearchCV, cross_val_score, ParameterGrid
from sklearn.metrics import mean_absolute_error,mean_squared_error, r2_score

from sklearn.tree import export_text

"""#**Data/Domain Understanding and Exploration**
##**load and inspect dataset**
"""

df_car=pd.read_csv("/content/drive/MyDrive/adverts.csv")
df_car

df_car.head()

df_car.shape

df_car.info()

"""###**Data Types**"""

# Checking data parsing by looking at the data types
data_types = df_car.dtypes
print(data_types)

"""year of registraion has wrong dtype

###**identify quantitative and qualitative features**
"""

#Identify numeric features
numeric_feat = df_car.select_dtypes(include=['float64', 'int64']).columns
print("Numeric Features:", numeric_feat)

# Identify categorical features
categorical_feat = df_car.select_dtypes(include=['object']).columns
print("Categorical Features:", categorical_feat)

# Histograms for numeric features
subset_df_car = df_car.sample(2000)
for col in numeric_feat:
    plt.figure(figsize=(6, 4))
    sns.histplot(subset_df_car[col], kde=True)
    plt.title(f'Distribution of {col}')
    plt.show()

categorical_variables = ['standard_make', 'vehicle_condition', 'body_type']
fig, axes = plt.subplots(nrows=len(categorical_variables), ncols=1, figsize=(10, 15))

for i, col in enumerate(categorical_variables):
    # Calculating average price for each category of subset of dataset
    avg_price_per_category =subset_df_car.groupby(col)['price'].mean().sort_values()
    sns.barplot(x=avg_price_per_category.values, y=avg_price_per_category.index, ax=axes[i])
    axes[i].set_title(f'Average Price by {col}')
    axes[i].set_xlabel('Average Price')
    axes[i].set_ylabel(col)

plt.tight_layout()
plt.show()

"""##**Descriptive statistics**"""

# Descriptive statistics for numeric columns
numeric_descriptive_stats = df_car.describe().round(2)
print(numeric_descriptive_stats)

df_car[['reg_code', 'crossover_car_and_van', 'public_reference']].describe(include='all')
df_car['crossover_car_and_van'].value_counts()

"""**identify good predictors**"""

correlation_matrix = df_car.corr()
print(correlation_matrix)

sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.show()

# Price Distribution
plt.figure(figsize=(6,4))
sns.histplot(df_car['price'], bins=50, kde=True)
plt.title('Distribution of Vehicle Prices')
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.xscale('log') # Using a log scale due to wide range of prices
plt.show()

# Mileage vs. Price
plt.figure(figsize=(6, 4))
sns.scatterplot(x='mileage', y='price', data=df_car)
plt.title('Mileage vs. Price')
plt.xlabel('Mileage')
plt.ylabel('Price')
plt.xscale('log')
plt.yscale('log')
plt.show()

# Year of Registration vs. Price
plt.figure(figsize=(6, 4))
sns.scatterplot(x='year_of_registration', y='price', data=df_car)
plt.title('Year of Registration vs. Price')
plt.xlabel('Year of Registration')
plt.ylabel('Price')
plt.show()

# Price Distribution by Vehicle Condition
plt.figure(figsize=(8, 6))
sns.boxplot(x='vehicle_condition', y='price', data=subset_df_car)
plt.title('Price Distribution by Vehicle Condition')
plt.xlabel('Vehicle Condition')
plt.ylabel('Price')
plt.yscale('log')
plt.show()

"""##**Data Cleaning**"""

df_car.nunique()

df_car.count()

"""##**Handle Missing Values**"""

#pd.set_option('display.max_rows', None)  # Show all rows
#pd.set_option('display.max_columns', None)  # Show all columns
#pd.set_option('display.width', None)  # Auto-detect the display width
#pd.set_option('display.max_colwidth', None)  # Show full content of each column

df_car.isnull().sum()

"""**Milage**"""

print(df_car['mileage'].value_counts())

df_car['mileage'].describe()

median=df_car["mileage"].median()
df_car["mileage"]=df_car["mileage"].fillna(median)
df_car['mileage'].isnull().sum()

"""**standard_colour, body_type , fuel_type**

"""

print(df_car[["standard_colour", "body_type", "fuel_type"]].value_counts())

df_car[["standard_colour", "body_type", "fuel_type"]].isnull().sum()

df_car["standard_colour"] =df_car["standard_colour"].fillna('White')
df_car[["body_type","fuel_type"]]=df_car[["body_type","fuel_type"]].fillna({'body_type': 'SUV', 'fuel_type': 'Diesel'})
df_car[["standard_colour","body_type","fuel_type"]].isnull().sum()

df_car["year_of_registration"].isnull().sum()

#Fill the NEW cars with 2021 by assuming that it is recent year
df_car.loc[df_car['vehicle_condition'] == 'NEW', 'year_of_registration'] = 2021
df_car["year_of_registration"].isnull().sum()

#and rest are filled by 2016 as it is most frequent one
df_car["year_of_registration"]=df_car["year_of_registration"].fillna(2016).astype(int)
df_car["year_of_registration"].isnull().sum()

#remove Erroneous value
df_car = df_car[df_car['year_of_registration'] >= 1886]

# Detecting outliers in 'price' and 'mileage' using boxplots
fig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 10))

# Boxplot for 'price'
sns.boxplot(x=df_car['price'], ax=axes[0])
axes[0].set_title('Boxplot of Price')

# Boxplot for 'mileage'
sns.boxplot(x=df_car['mileage'], ax=axes[1])
axes[1].set_title('Boxplot of Mileage')

# Boxplot for 'year_of_registration' to detect outliers
plt.figure(figsize=(10, 6))
sns.boxplot(x=df_car['year_of_registration'])
plt.title('Boxplot of Year of Registration')
plt.show()


plt.tight_layout()
plt.show()

# 1. Handle Outliers
upper_limit_mileage = df_car['mileage'].quantile(0.99)
df_car= df_car[df_car['mileage'] < upper_limit_mileage]
upper_limit_price = df_car['price'].quantile(0.99)
df_car = df_car[df_car['price'] < upper_limit_price]

df_car.info()

"""**reshape,**"""

correlation_matrix = df_car.corr()
print(correlation_matrix['price'])

plt.figure(figsize=(6, 4))
sns.heatmap(df_car.corr(), annot=True, fmt=".2f")
plt.show()

#drop columns
columns= ['public_reference', 'reg_code', 'crossover_car_and_van']
df_car.drop(columns=columns, inplace=True)

# Creating histograms for numerical variables
fig, axes = plt.subplots(1, 3, figsize=(18, 5))

# Plotting 'mileage'
sns.histplot(df_car['mileage'], bins=30, ax=axes[0], kde=True)
axes[0].set_title('Distribution of Mileage')
axes[0].set_xlabel('Mileage')
axes[0].set_ylabel('Frequency')

# Plotting 'year_of_registration'
sns.histplot(df_car['year_of_registration'].dropna(), bins=30, ax=axes[1], kde=True)
axes[1].set_title('Distribution of Year of Registration')
axes[1].set_xlabel('Year of Registration')
axes[1].set_ylabel('Frequency')

# Plotting 'price'
sns.histplot(df_car['price'], bins=30, ax=axes[2], kde=True)
axes[2].set_title('Distribution of Price')
axes[2].set_xlabel('Price')
axes[2].set_ylabel('Frequency')

plt.tight_layout()
plt.show()

new_order = ['mileage', 'standard_colour', 'standard_make', 'standard_model', 'vehicle_condition', 'year_of_registration', 'body_type', 'fuel_type', 'price']
df_car= df_car[new_order]

"""##**rename**"""

df_car = df_car.rename(columns={'standard_colour': 'colour','standard_make': 'make','standard_model': 'model','vehicle_condition':'condition','year_of_registration':'reg_year'})

df_car.to_csv('CleanedData.csv', index=False)

df = pd.read_csv('/content/CleanedData.csv')

df.head(5)

"""####**Select Categories for onehotencoding and target encoding**"""

cat_feat_hot= ['condition','fuel_type'] #for onehotencoding
cat_feat_target=  [ 'body_type','colour','make','model']  #for target

"""####**OnehotEncoding for low cardinality features**"""

# Apply one-hot encoding first
encoder = OneHotEncoder()
df_encoded = encoder.fit_transform(df[cat_feat_hot]).toarray()
encoded_columns = encoder.get_feature_names_out(cat_feat_hot)
df = pd.concat([df.drop(cat_feat_hot, axis=1), pd.DataFrame(df_encoded, columns=encoded_columns)], axis=1)
df.head(5)

"""##**Splitting**"""

target = 'price'
X = df.drop('price', axis=1)
y = df['price']
#splitting
X_train,X_temp,y_train,y_temp = train_test_split(X, y, test_size=0.2, random_state=42)
X_val,X_test,y_val,y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42)

"""####**Target Encoding after splitting**
**(to avoid leakage)**
"""

#target-encoding
target_encoder = ce.TargetEncoder()
X_train[cat_feat_target] = target_encoder.fit_transform(X_train[cat_feat_target], y_train)
X_val[cat_feat_target] = target_encoder.transform(X_val[cat_feat_target])
X_test[cat_feat_target] = target_encoder.transform(X_test[cat_feat_target])

X_train.head(5)

"""**Scaling of numeric features**"""

# Rescale Numerical Columns
scaler = MinMaxScaler()
numerical_cols = X_train.select_dtypes(include=['int64', 'float64']).columns
X_train[numerical_cols] = scaler.fit_transform(X_train[numerical_cols])
X_test[numerical_cols] = scaler.transform(X_test[numerical_cols])
X_val[numerical_cols] = scaler.transform(X_val[numerical_cols])

X_train.head(2)

# X_train.to_csv('X_train.csv', index=False)
# X_test.to_csv('X_test.csv', index=False)
# y_train.to_csv('y_train.csv', index=False)
# y_test.to_csv('y_test.csv', index=False)
# X_val.to_csv('X_val.csv', index=False)
# y_val.to_csv('y_val.csv', index=False)

"""#**Model Building**

**Cross validation on each model**
"""

# Instantiate each of the models
linr = LinearRegression()
knr = KNeighborsRegressor()
dtr = DecisionTreeRegressor()

models = []
models.append(('LINR', LinearRegression()))
models.append(('KNR', KNeighborsRegressor()))
models.append(('DTR', DecisionTreeRegressor()))

# Set a seed
seed = 42

# Sampling from the training set
sample_size = int(0.3 * len(X_train))
X_train_sample, _, y_train_sample, _ = train_test_split(X_train, y_train, train_size=sample_size, random_state=seed)

from sklearn.model_selection import KFold, cross_val_score
np.random.seed(seed)

names = []
mse_means = []
mae_means = []
r2_means = []

for name, model in models:
    k_fold = KFold(n_splits=5, shuffle=True, random_state=seed)


    mse_scores = -cross_val_score(model, X_train_sample, y_train_sample, cv=k_fold, scoring="neg_mean_squared_error")
    mae_scores = -cross_val_score(model, X_train_sample, y_train_sample, cv=k_fold, scoring="neg_mean_absolute_error")
    r2_scores = cross_val_score(model, X_train_sample, y_train_sample, cv=k_fold, scoring="r2")


    names.append(name)
    mse_means.append(mse_scores.mean())
    mae_means.append(mae_scores.mean())
    r2_means.append(r2_scores.mean())

    # Print results
    print(f"{name}:")
    print(f"  MSE: {mse_scores.mean().round(3)}" , f"  MAE: {mae_scores.mean().round(3)}",f"  R2: {r2_scores.mean().round(3)}")
    # print(f"  MAE: {mae_scores.mean().round(3)}")
    # print(f"  R2: {r2_scores.mean().round(3)}")
    print()

# Print results
print(f"{name}:")
print(f"  MSE: {mse_scores.mean().round(3)}" , f"  MAE: {mae_scores.mean().round(3)}",f"  R2: {r2_scores.mean().round(3)}")

# Function to create bar plots
def create_bar_plot(metric_means, metric_name):
    plt.bar(names, metric_means)
    plt.xticks(rotation=45)
    plt.ylabel(metric_name)
    plt.title(f'{metric_name} by Model')

# Create and show plots
plt.figure(figsize=(18, 5))

plt.subplot(1, 3, 1)
create_bar_plot(mse_means, "MSE")

plt.subplot(1, 3, 2)
create_bar_plot(mae_means, "MAE")

plt.subplot(1, 3, 3)
create_bar_plot(r2_means, "R²")

plt.tight_layout()
plt.show()

"""##**DecisionTree**
**initialize and Train a Model**
"""

DT_model = DecisionTreeRegressor(max_depth=3,random_state=seed)
DT_model.fit(X_train, y_train)

from sklearn.tree import export_text
print(
    export_text(DT_model, feature_names=X_train.columns.to_list())
)

"""##**Tune Model using GridSearchCV and Model Ranking**

"""

dt_params = {
    'max_depth': [3, 5, 7, 10, 20],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

DT_grid = GridSearchCV(DecisionTreeRegressor(), dt_params, cv=5, scoring='neg_mean_squared_error',return_train_score=True)
Grid_result=DT_grid.fit(X_train, y_train)

Grid_df = pd.DataFrame(Grid_result.cv_results_)

Grid_df.columns

Grid_df[[
    'param_max_depth', 'param_min_samples_leaf', 'param_min_samples_split',
    'mean_train_score', 'std_train_score',
    'mean_test_score', 'std_test_score', 'rank_test_score'
]].sort_values('rank_test_score').head()

# Select the best model
Grid_result.best_estimator_

"""##**Evaluate on validation set**"""

best_DT=Grid_result.best_estimator_
y_pred_dt=best_DT.predict(X_val)
mae=mean_absolute_error(y_val, y_pred_dt)
R2=r2_score(y_val, y_pred_dt)
mse=mean_squared_error(y_val, y_pred_dt)

print("MSE for Decision Tree(val_set):", round(mse, 3))
print("MAE for Decision Tree(val_set):", round(mae, 3))
print("R2 for Decision Tree(val_set):", round(R2, 3))

# Visualization of Actual vs Predicted Values and Residuals
def plot_predictions(y_val, y_pred_dt, title):
    plt.figure(figsize=(8, 6))
    plt.scatter(y_val, y_pred_dt, alpha=0.6)
    plt.plot([y_val.min(), y_val.max()], [y_val.min(), y_val.max()], 'k--', lw=3)
    plt.xlabel('Actual')
    plt.ylabel('Predicted')
    plt.title(title)
    plt.show()

def plot_residuals(y_val, y_pred_dt, title):
   plt.figure(figsize=(8, 6))
   residuals = y_val - y_pred_dt
   sns.histplot(residuals,bins=20, kde=True)
   plt.title(title)
   plt.xlabel('Residuals')
   plt.ylabel('Frequency')
   plt.show()

plot_predictions(y_val, y_pred_dt, 'Actual vs Predicted (val_Set) - DT')
plot_residuals(y_val, y_pred_dt, 'Residuals (val_Set) - DT')

#comparison
actual_vs_predicted = pd.DataFrame({
    'Actual': y_val,
    'Predicted': y_pred_dt
})

# Display a sample
actual_vs_predicted.sample(10)

# Line Plot
plt.figure(figsize=(10, 6))
sns.lineplot(data=actual_vs_predicted.sample(100).reset_index(drop=True))  # I use Sample 100 for better visibility
plt.title('Actual vs Predicted Values - validation set')
plt.xlabel('Data')
plt.ylabel('Price')
plt.show()

"""##**Evaluate Model on TEST set**"""

best_DT=Grid_result.best_estimator_
#now Use the best model to make predictions on the test set
y_pred_DT = best_DT.predict(X_test)

#Evaluate the performance
mae_dt=mean_absolute_error(y_test, y_pred_DT)
R2_dt=r2_score(y_test, y_pred_DT)
mse_dt=mean_squared_error(y_test, y_pred_DT)
print("MSE for Decision Tree(test_set):",round(mse_dt, 3))
print("MAE for Decision Tree(test_set):",round(mae_dt, 3))
print("R2 for Decision Tree(test_set):",round(R2_dt, 3))

cv_scores_dt = cross_val_score(best_DT, X_train, y_train)
cv_scores_dt

# Visualization of Actual vs Predicted Values and Residuals
def plot_predictions(y_test, y_pred_DT, title):
    plt.figure(figsize=(8,6))
    plt.scatter(y_test, y_pred_DT, alpha=0.6)
    plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=3)
    plt.xlabel('Actual')
    plt.ylabel('Predicted')
    plt.title(title)
    plt.show()

def plot_residuals(y_test, y_pred_DT, title):
    residuals = y_test- y_pred_DT
    plt.figure(figsize=(8, 6))
    sns.histplot(residuals,bins=20, kde=True)
    plt.title(title)
    plt.xlabel('Residuals')
    plt.ylabel('Frequency')
    plt.show()

plot_predictions(y_test, y_pred_DT, 'Actual vs Predicted (TEST_set) - DT')
plot_residuals(y_test, y_pred_DT, 'Residuals (TEST_set) - DT')

# comparison
actual_vs_predicted = pd.DataFrame({
    'Actual': y_test,
    'Predicted': y_pred_DT

})

# Display a sample
actual_vs_predicted.sample(10)

# Line Plot
plt.figure(figsize=(10, 6))
sns.lineplot(data=actual_vs_predicted.sample(100).reset_index(drop=True))
plt.title('Actual vs Predicted Values (DT) - Test Set')
plt.xlabel('Sample Index')
plt.ylabel('Price')
plt.show()

"""##**Feature Importance**"""

#feature importance from the Decision Tree
importances = best_DT.feature_importances_
features = X_train.columns
for feature_name, imp in zip(features, importances):
    print(f"{feature_name}: {imp.round(4)}")

# Plotting
# Create a bar plot
plt.figure(figsize=(8, 6))
plt.barh(features, importances, color='skyblue')
plt.title('Feature Importance from Decision Tree')
plt.show()

"""#**KNeighborsRegressor**
I used sample data to train knn otherwise it takes too much time.
"""

# Sampling from the training set
sample_size = int(0.3 * len(X_train))
X_train_sample, _, y_train_sample, _ = train_test_split(X_train, y_train, train_size=sample_size, random_state=seed)

# Train the kNN model
knn_model = KNeighborsRegressor(n_neighbors=15)
knn_model.fit(X_train_sample, y_train_sample)

"""tried this model using different ranges 1-15, 1-20 but finally fixed that as it is now to reduced its execution time."""

# Hyperparameter tuning (Grid Search)
param_grid = {'n_neighbors': [3,5,7,10,15]}
knn_Grid= GridSearchCV(knn_model, param_grid, cv=5, scoring='neg_mean_squared_error',return_train_score=True)
knn_result=knn_Grid.fit(X_train_sample, y_train_sample)
knn_df=pd.DataFrame(knn_result.cv_results_)

knn_df.columns

knn_df[[
    'param_n_neighbors', 'mean_train_score', 'std_train_score',
    'mean_test_score', 'std_test_score', 'rank_test_score'
]].sort_values('rank_test_score').head()

knn_result.best_params_

knn_result.best_estimator_

# Select the best model
best_knn = knn_result.best_estimator_

"""##**validate model**"""

knn_pred= best_knn.predict(X_val)
mae=mean_absolute_error(y_val,knn_pred)
R2=r2_score(y_val,knn_pred)
mse=mean_squared_error(y_val, knn_pred)
print("MSE for KNN(val_set):",mse)
print("MAE for KNN(val_set):",mae)
print("R2 for KNN(val_set):",R2)

# Visualization of Actual vs Predicted Values and Residuals
def plot_predictions(y_val,knn_pred, title):
    plt.figure(figsize=(8, 6))
    plt.scatter(y_val, knn_pred, alpha=0.6)
    plt.plot([y_val.min(), y_val.max()], [y_val.min(), y_val.max()], 'k--', lw=3)
    plt.xlabel('Actual')
    plt.ylabel('Predicted')
    plt.title(title)
    plt.show()

def plot_residuals(y_val, knn_pred, title):
    residuals = y_val - knn_pred
    plt.figure(figsize=(8, 6))
    sns.histplot(residuals,bins=20, kde=True)
    plt.xlabel('Residual')
    plt.ylabel('Frequency')
    plt.title(title)
    plt.show()
    # sns.histplot(residuals,bins=20, kde=True)
    # plt.title(title)
    # plt.xlabel('Residuals')
    # plt.show()

plot_predictions(y_val, knn_pred, 'Actual vs Predicted (val_set) - KNN')
plot_residuals(y_val, knn_pred, 'Residuals (val_set) - KNN')

"""##**here evaluate on test**"""

knn_Pred= best_knn.predict(X_test)
mae_knn=mean_absolute_error(y_test,knn_Pred)
R2_knn=r2_score(y_test,knn_Pred)
mse_knn=mean_squared_error(y_test, knn_Pred)
print("MSE for KNN(test_set):",mse_knn)
print("MAE for KNN(test_set):",mae_knn)
print("R2 for KNN(test_set):",R2_knn)

# Perform cross-validation on training set using the best model
cv_scores_knn = cross_val_score(best_knn, X_train, y_train)

# Print the cross-validation scores
print("Cross-Validation Scores:", cv_scores_knn)
print(f"Mean CV Score: {cv_scores_knn.mean():.4f}")

# Visualization of Actual vs Predicted Values and Residuals
def plot_predictions(y_test,knn_Pred, title):
    plt.figure(figsize=(8,6))
    plt.scatter(y_test, knn_Pred, alpha=0.6)
    plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=3)
    plt.xlabel('Actual')
    plt.ylabel('Predicted')
    plt.title(title)
    plt.show()

def plot_residuals(y_val, knn_pred, title):
    residuals = y_test - knn_Pred
    plt.figure(figsize=(8, 6))
    sns.histplot(residuals,bins=20, kde=True)
    plt.xlabel('Residual')
    plt.ylabel('Frequency')
    plt.title(title)
    plt.show()


plot_predictions(y_test, knn_Pred, 'Actual vs Predicted (test_set) - KNN')
plot_residuals(y_test, knn_Pred, 'Residuals (test_set) - KNN')

# Obtain the score
train_score = knn_model.score(X_train_sample, y_train_sample)
test_score = knn_model.score(X_test, y_test)

print('Training Score: %.3f' % train_score)
print('Test Score: %.3f' % test_score)

# comparison
actual_vs_predicted = pd.DataFrame({
    'Actual': y_test,
    'Predicted': knn_Pred

})

# Display a sample
actual_vs_predicted.sample(10)

# Line Plot
plt.figure(figsize=(10, 6))
sns.lineplot(data=actual_vs_predicted.sample(100).reset_index(drop=True))
plt.title('Actual vs Predicted Values -(knn) Test Set')
plt.xlabel('Sample Index')
plt.ylabel('Price')
plt.show()

"""##**Linear Regression**"""

#Instantiate the Linear Regression model
linear_model = LinearRegression()
# Train the model on the training set
linear_model.fit(X_train, y_train)

"""**validat**"""

# Validate the model
y_val_pred = linear_model.predict(X_val)
mae=mean_absolute_error(y_val, y_val_pred)
R2=r2_score(y_val, y_val_pred)
mse_LR=mean_squared_error(y_val, y_val_pred)
print("MSE for LR(Val_set):",mse)
print("MAE for LR(VAL_set):",mae)
print("R2 for LR(VAL_set):",R2)

plt.figure(figsize=(8, 6))
plt.scatter(y_val, y_val_pred, alpha= 0.6)

plt.plot([y_val.min(), y_val.max()], [y_val.min(), y_val.max()], 'k--', lw=3)
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.title('Actual vs Predicted Values for Linear Regression')
plt.show()

# Residuals plot for Linear Regression
residuals = y_val - y_val_pred
plt.figure(figsize=(8, 6))
sns.histplot(residuals,bins=20, kde=True)
plt.xlabel('Residual')
plt.ylabel('Frequency')
plt.title('Distribution of Residuals for Linear Regression')
plt.show()

"""###**evaluate on TEst**"""

# test the model
y_LR_pred = linear_model.predict(X_test)
mae_LR=mean_absolute_error(y_test, y_LR_pred)
R2_LR=r2_score(y_test, y_LR_pred)
mse_LR=mean_squared_error(y_test, y_LR_pred)
print("MSE for LR(test_set):",mse_LR)
print("MAE for LR(test_set):",mae_LR)
print("R2 for LR(test_set):",R2_LR)

# Perform cross-validation on the entire training set using the best model
cv_scores_lin = cross_val_score(linear_model, X_train, y_train)
cv_scores_lin

plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_LR_pred,alpha =0.6)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=3)
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.title('Actual vs Predicted Values for Linear Regression(test_set)')
plt.show()

# Residuals plot for Linear Regression
residuals = y_test - y_LR_pred
plt.figure(figsize=(8, 6))
sns.histplot(residuals,bins=20, kde=True)
plt.xlabel('Residual')
plt.ylabel('Frequency')
plt.title('Distribution of Residuals for Linear Regression(test-set)')
plt.show()

# comparison
actual_vs_predicted = pd.DataFrame({
    'Actual': y_test,
    'Predicted':linear_model.predict(X_test)
})

actual_vs_predicted.sample(10)

# Line Plot
plt.figure(figsize=(10, 6))
sns.lineplot(data=actual_vs_predicted.sample(100).reset_index(drop=True))  # Sample 100 for better visibility
plt.title('Actual vs Predicted Values - Line Plot')
plt.xlabel('Sample Index')
plt.ylabel('Price')
plt.show()

# Get the coefficients
coefficients = linear_model.coef_
features = X_train.columns

for feature_name, coef in zip(features, coefficients):
    print(f"Coef for {feature_name}: {coef.round(3)}")

# Create a bar plot
plt.figure(figsize=(8, 6))
plt.barh(features, coefficients, color='skyblue')
plt.xlabel('Coefficient Value')
plt.title('Feature Importance from Linear Regression Coefficients')
plt.show()



"""##**Evaluation of Different Models**"""

model_scores = {
    'Model': ['LR','DT', 'KNN'],
    'R2_Score': [R2_LR,R2_dt, R2_knn],
    'Mean Training Score': [cv_scores_lin.mean(), cv_scores_dt.mean(), cv_scores_knn.mean()],
    'Score Difference': [cv_scores_lin.mean() - R2_LR,
                         cv_scores_dt.mean() - R2_dt,
                         cv_scores_knn.mean() -R2_knn,
                        ]
}


scores_df = pd.DataFrame(model_scores)
print(scores_df)

# Line plot for test accuracy
plt.figure(figsize=(10, 6))
sns.lineplot(x=scores_df['Model'], y=scores_df['R2_Score'],
             color='skyblue', label='R_score', marker='o')

# Line plot for mean CV scores
sns.lineplot(x=scores_df['Model'], y=scores_df['Mean Training Score'],
             color='orange', label='Mean Training Score', marker='o')

# Adding labels and title
plt.xlabel('Models')
plt.ylabel('Scores')
plt.title('Test Score and Mean Training Scores for Different Models')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))  # Place legend outside the plot area

# Show plot
plt.tight_layout()
plt.show()

# Plotting
plt.figure(figsize=(10, 6))
for column in scores_df.columns[1:]:
    plt.plot(scores_df['Model'], scores_df[column], marker='o', label=column)

plt.title('Model Performance Comparison')
plt.xlabel('Model')
plt.ylabel('Scores')
plt.legend()
plt.grid(True)
plt.show()

# Plotting a bar plot
plt.figure(figsize=(10, 6))

# Width of a bar
width = 0.2

# Set position of bar on X axis
r1 = np.arange(len(scores_df['Model']))
r2 = [x + width for x in r1]
r3 = [x + width for x in r2]

# Make the plot
plt.bar(r1, scores_df['R2_Score'], color='b', width=width, edgecolor='grey', label='R2_Score')
plt.bar(r2, scores_df['Mean Training Score'], color='g', width=width, edgecolor='grey', label='Mean Training Score')
plt.bar(r3, scores_df['Score Difference'], color='r', width=width, edgecolor='grey', label='Score Difference')

# Add labels
plt.xlabel('Model', fontweight='bold')
plt.ylabel('Scores')
plt.xticks([r + width for r in range(len(scores_df['Model']))], scores_df['Model'])

plt.title('Model Performance Comparison')
plt.legend()
plt.show()

"""![Screenshot 2025-05-17 1.13.53 PM.png](data:image/png;base64,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)"""